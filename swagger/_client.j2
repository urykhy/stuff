class client
{
    asio_http::Alive::ManagerPtr m_HttpClient;
    const std::string m_Base;
    log4cxx::LoggerPtr sLogger = Logger::Get("http");

public:
    client(asio_http::Alive::ManagerPtr aHttpClient, const std::string& aBase)
    : m_HttpClient(aHttpClient)
    , m_Base(aBase)
    {}

    {% call(doc, path, method, name) _for_every_method(doc) %}
        using {{ name }}_parameters = {{ Aname }}::{{ name }}_parameters;

        {# detect if we have only one successul response kind #}
        {%- set variant_list = [] %}
        {%- call(name, k, response) _for_every_response(doc, path, method, name) -%}
            {%- if k | int < 300 %}
                {% do variant_list.append( Aname + "::" + name + "_response_" + k ) %}
            {%- endif %}
        {%- endcall %}
        {%- if variant_list | length == 1 %}
            {%- set returnType = variant_list | first %}
        {%- else %}
            using {{ name }}_response_v = std::variant<
                {{ variant_list | join(',') }}
            >;
            {%- set returnType = name + "_response_v" %}
        {%- endif %}

        {# client response with successful struct, or throw #}
        {{ returnType }} {{ name }}(const {{ name }}_parameters& aRequest {% if x_jaeger %}, std::optional<Jaeger::Metric::Step*> aTraceParent = std::nullopt{% endif %})
        {
            namespace http = boost::beast::http;
            asio_http::ClientRequest sRequest = aRequest.__format();
            sRequest.url = m_Base + sRequest.url;
            {% if x_jaeger %}
            std::unique_ptr<Jaeger::Metric::Step> sTraceCall;
            if (aTraceParent)
            {
                sTraceCall = std::make_unique<Jaeger::Metric::Step>((*aTraceParent)->child("call {{ name }}"));
                sRequest.headers["traceparent"] = sTraceCall->extract().traceparent();
            }
            {% endif %}
            INFO("{{ method }} " << sRequest.url);
            auto sResponse = m_HttpClient->async(std::move(sRequest)).get();
            const auto sFromSwagger = !sResponse["X-From-Swagger"].empty();

            {# error codes from swagger #}
            if (sFromSwagger)
            {
                if (sResponse.result() == asio_http::http::status::bad_request)
                    throw std::invalid_argument(sResponse.body());
                throw Exception::HttpError(
                    sResponse.body(),
                    static_cast<unsigned>(sResponse.result()));
            }

            {# normal user responses #}
            {% call(name, k, response) _for_every_response(doc, path, method, name) %}
                if (sResponse.result() == asio_http::http::int_to_status({{ k }}))
                {
                    {{ name }}_response_{{ k }} sResponseBody;
                    sResponseBody.__parse(sResponse);
                    {%- if k | int < 300 %}
                        return sResponseBody;
                    {%- else %}
                        throw sResponseBody;
                    {%- endif %}
                }
            {% endcall %}

            {# no match - throw #}
            throw Exception::HttpError(
                "unexpected http response: " + sResponse.body(),
                static_cast<unsigned>(sResponse.result()));
        }
    {% endcall %}
};
