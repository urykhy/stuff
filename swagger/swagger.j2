#include <regex>
#include <set>
#include <string>
#include <variant>
#include <vector>

#include "Format.hpp"

#include <asio_http/Client.hpp>
#include <asio_http/Router.hpp>
#include <cbor/cbor.hpp>
#include <container/Algorithm.hpp>
#include <exception/Error.hpp>

{% macro complex_schema(schema, name='body', opt=False) -%}
    {%- for s in schema | swagger_decode(name) %}
        {%- if 'fields' in s %}
            struct {{ s.type }} {
                {%- for t in s.fields | sort(attribute='name') %}
                    {{ t.type | swagger_type }} {{ t.name }} = {};
                {%- endfor %}
                ::Json::Value to_json() const {
                    ::Json::Value sValue(::Json::objectValue);
                    {%- for t in s.fields | sort(attribute='name') %}
                        sValue["{{ t.name }}"] = Format::Json::to_value({{ t.name }});
                    {%- endfor %}
                    return sValue;
                }
                void from_json(const ::Json::Value& aJson) {
                    {%- for t in s.fields | sort(attribute='name') %}
                        Parser::Json::from_value(aJson, "{{ t.name }}", {{ t.name }});
                    {%- endfor %}
                }
                void cbor_write(cbor::ostream& aOut) const {
                    cbor::write(aOut, {{ s.fields | sort(attribute='name') | map(attribute='name') | join(',') }});
                }
                void cbor_read(cbor::istream& aIn) {
                    cbor::read(aIn, {{ s.fields | sort(attribute='name') | map(attribute='name') | join(',') }});
                }
            };
            {%- if loop.last %}
                {%- if opt == True %}std::optional<{% endif %}{{ s.type | swagger_type }}{%- if opt %}>{% endif %} {{ s.name }} = {};
            {%- endif %}
        {%- else %}
            {%- set x_opt = opt == True and s.type is not swagger_is_array %}
            {%- if x_opt == True %}std::optional<{% endif %}{{ s.type | swagger_type }}{%- if x_opt %}>{% endif %} {{ s.name }} = {};
        {%- endif %}
    {%- endfor %}
{%- endmacro %}

{% macro _err_class(k) %}
    {%- if k | int in (400, 403, 404, 405, 412, 413, 417, 422, 501) -%}
        std::invalid_argument
    {%- else -%}
        std::runtime_error
    {%- endif -%}
{% endmacro %}

{% macro _name(n) %}
    {%- if n is mapping %}
        {{- n.name | lower | replace('-','_') -}}
    {%- else %}
        {{- n | lower | replace('-','_') -}}
    {%- endif %}
{%- endmacro %}

{% macro _for_every_method(doc) %}
    {%- for path in doc['paths'] %}
        {%- for method in doc['paths'][path] if method in ["get", "put", "post", "head", "delete"] %}
            {%- set name = _name(doc['paths'][path][method]['operationId']) %}
            {%- if name == '' %}
                {%- set name = (doc['servers'][0]['url'], path) | join('') | swagger_prefix | replace('/','_') %}
            {% endif %}
            {{ caller(doc, path, method, name) }}
        {%- endfor %}
    {%- endfor %}
{% endmacro %}

{% macro _for_every_response(doc, path, method, name) %}
    {%- for k,v in doc['paths'][path][method].get('responses',{}) | dictsort %}
        {%- set response = v | swagger_expand_ref %}
        {{ caller(name, k, response) }}
    {%- endfor %}
{% endmacro %}

namespace api {
    {% set Aname = (doc['info']['title'], doc['info']['version']) | join('_') | replace('.', '_') %}
    namespace {{ Aname }}
    {
        {% call(doc, path, method, name) _for_every_method(doc) %}
            struct {{ name }}_parameters {
                {# parameters #}
                {%- set p1 = doc['paths'][path].get('parameters', []) | swagger_expand_refs %}
                {%- set p2 = doc['paths'][path][method].get('parameters', []) | swagger_expand_refs %}
                {%- set params = p1 + p2 | sort(attribute='name') %}

                {%- for param in params %}
                    {{ complex_schema(param['schema'], _name(param), True) }}
                {%- endfor %}

                {# body #}
                {%- set body = doc['paths'][path][method].get('requestBody',{}).get('content',{}) %}
                {%- set binary = body.get('application/octet-stream',{}) | length %}
                {%- set json = body.get('application/json',{}) | length %}
                {%- if binary > 0 %}
                    std::string body;
                {%- elif json > 0 %}
                    {%- set schema = body.get('application/json').get('schema') %}
                    {{ complex_schema(schema) }}
                {% endif %}

                void __parse(const asio_http::Request& aRequest) {
                    auto sQuery = aRequest.target();
                    std::string_view sQueryView(sQuery.data(), sQuery.size());

                    {% if params | selectattr('in', 'equalto', 'path') | list | length > 0 %}
                    Parser::http_path_params(sQueryView, "{{ (doc['servers'][0]['url'], path) | join('') | swagger_path }}", [this](auto aName, auto aValue) {
                        {%- for param in params if param['in'] == 'path' %}
                            if (aName == "{{ param.name }}") { swagger::parse(aValue, {{ _name(param) }}); return; }
                        {%- endfor %}
                        throw std::invalid_argument("unexpected param `" + std::string(aName) + '`');
                    });
                    {%- endif %}

                    Parser::http_query(sQueryView, [this](auto aName, auto aValue) {
                        {%- for param in params if param['in'] == 'query' %}
                            if (aName == "{{ param.name }}") { swagger::parse(std::string(aValue), {{ _name(param) }}); return; }
                        {%- endfor %}
                        throw std::invalid_argument("unexpected param `" + std::string(aName) + '`');
                    });

                    {%- for param in params if param['in'] == 'header' %}
                        if (auto sValue = Parser::url_decode(aRequest["{{ param.name }}"].to_string()); !sValue.empty())
                            swagger::parse(sValue, {{ _name(param) }});
                    {%- endfor %}

                    {# limits #}
                    {%- for param in params if param['schema'].get('enum', none) is not none %}
                        if ( swagger::is_specified({{ _name(param) }}) ) {
                            static const std::set<{{ param.schema.type | swagger_type }}> sAllowed ={ {{ param | swagger_enum }} };
                            if (sAllowed.find({{ _name(param) }}.value()) == sAllowed.end())
                                throw std::invalid_argument("param `{{ param.name }}` has not allowed value");
                        }
                    {%- endfor %}

                    {# number limits #}
                    {%- for param in params if param['schema'].get('type', none) in ('integer','number') %}
                        {% with %}
                        {%- set xname = _name(param) %}
                        {%- set schema = param['schema'] %}
                        {%- set have_limit = ('minimum' in schema) or ('maximum' in schema) or ('multipleOf' in schema) %}
                        {%- if have_limit %}
                        if ( swagger::is_specified({{ xname }}) ) {
                            {%- if 'minimum' in schema %}
                                if ({{ xname }}.value() < {%- if schema.get('exclusiveMinimum', false) is false %}={%- endif %} {{ schema['minimum'] }})
                                    throw std::invalid_argument("param `{{ param.name }}` violates minimum limit");
                            {%- endif %}
                            {%- if 'maximum' in schema %}
                                if ({{ xname }}.value() > {%- if schema.get('exclusiveMaximum', false) is false %}={%- endif %} {{ schema['maximum'] }})
                                    throw std::invalid_argument("param `{{ param.name }}` violates maximum limit");
                            {%- endif %}
                            {%- if 'multipleOf' in schema %}
                                if ({{ xname }}.value() % {{ schema['multipleOf'] }} != 0)
                                    throw std::invalid_argument("param `{{ param.name }}` violates multipleOf limit");
                            {%- endif %}
                        }
                        {%- endif %}
                        {%- endwith %}
                    {%- endfor %}

                    {# string limits #}
                    {%- for param in params if param['schema'].get('type', none) == 'string' %}
                        {% with %}
                        {%- set xname = _name(param) %}
                        {%- set schema = param['schema'] %}
                        {%- set have_limit = ('minLength' in schema) or ('maxLength' in schema) or ('pattern' in schema) %}
                        {%- if have_limit %}
                        if ( swagger::is_specified({{ xname }}) ) {
                            {%- if 'minLength' in schema %}
                                if ({{ xname }}.value().size() < {{ schema['minLength'] }})
                                    throw std::invalid_argument("param `{{ param.name }}` violates minimum string length");
                            {%- endif %}
                            {%- if 'maxLength' in schema %}
                                if ({{ xname }}.value().size() > {{ schema['maxLength'] }})
                                    throw std::invalid_argument("param `{{ param.name }}` violates maximum string length");
                            {%- endif %}
                            {%- if 'pattern' in schema %}
                                if (std::regex_match({{ xname }}.value(), std::regex("{{ schema['pattern'] }}")))
                                    throw std::invalid_argument("param `{{ param.name }}` violates pattern");
                            {%- endif %}
                        }
                        {%- endif %}
                        {%- endwith %}
                    {%- endfor %}

                    {# array limits #}
                    {%- for param in params if param['schema'].get('type', none) == 'array' %}
                    {% with %}
                        {%- set xname = _name(param) %}
                        {%- set schema = param['schema'] %}
                        {%- set have_limit = ('minItems' in schema) or ('maxItems' in schema) or ('uniqueItems' in schema) %}
                        {%- if have_limit %}
                            {%- if 'minItems' in schema %}
                                if ({{ xname }}.size() < {{ schema['minItems'] }})
                                    throw std::invalid_argument("param `{{ param.name }}` violates minimum array length");
                            {%- endif %}
                            {%- if 'maxItems' in schema %}
                                if ({{ xname }}.size() > {{ schema['maxItems'] }})
                                    throw std::invalid_argument("param `{{ param.name }}` violates maximum array length");
                            {%- endif %}
                            {%- if 'uniqueItems' in schema %}
                                if (!Container::is_unique({{ xname }}))
                                    throw std::invalid_argument("param `{{ param.name }}` contain duplicates");
                            {%- endif %}
                        {%- endif %}
                        {%- if param.in == 'query' %}
                            {%- if param.get('style','form') != 'form' or param.get('explode', true) != false %}
                                {{ swagger_raise('only [style=form, explode=false] arrays are supported in query') }}
                            {%- endif %}
                        {%- elif param.in in ('path', 'header') %}
                            {%- if param.get('style','simple') != 'simple' %}
                                {{ swagger_raise('only [style=simple] arrays are supported in path') }}
                            {%- endif %}
                        {%- endif %}
                    {%- endwith %}
                    {%- endfor %}

                    {# default value #}
                    {%- for param in params if param['schema'].get('default', none) is not none %}
                        {%- set d = param['schema']['default'] %}
                        if ( !swagger::is_specified({{ _name(param) }}) )
                            {{ _name(param) }} =
                            {%- if d is string -%}
                                "{{ d }}"
                            {%- elif d is boolean -%}
                                {%- if d -%} true {%- else -%} false {%- endif -%}
                            {%- else -%}
                                {{ d }}
                            {%- endif -%};
                    {%- endfor %}

                    {# required flag #}
                    {%- for param in params if param['required'] and param['schema'].get('default', none) is none %}
                        if ( !swagger::is_specified({{ _name(param) }}) )
                            throw std::invalid_argument("required param `{{ param.name }}` not specified");
                    {%- endfor %}

                    {# parse body #}
                    {%- if binary > 0 %}
                        body = aRequest.body();
                    {%- elif json > 0 %}
                        if (aRequest["Content-Type"] == "application/cbor") {
                            auto sIn = cbor::imemstream(aRequest.body());
                            cbor::read(sIn, body);
                        } else {
                            const auto sJson = Parser::Json::parse(aRequest.body());
                            Parser::Json::from_value(sJson, body);
                        }
                    {%- endif %}
                }

                asio_http::ClientRequest __format() const
                {
                    namespace http = boost::beast::http;
                    asio_http::ClientRequest sRequest={
                        .method = http::verb::{{ method | swagger_method }},
                        .url = "{{ doc['servers'][0]['url'] | join('') | swagger_prefix }}",
                        .headers = { {asio_http::http::field::accept, "application/cbor"} }
                    };

                    std::string sPath;
                    {%- for x in path.split('/') %}
                    {%- if x | length() > 0 %}
                        {%- set fbegin = x.find('{') %}
                        {%- set rbegin = x.rfind('}') %}
                        {%- if fbegin > -1 and rbegin > -1 %}
                            {%- set xName = x[fbegin+1:rbegin] %}
                            {%- for param in params if param.in == 'path' and param.name == xName %}
                                sPath += (std::string("/")
                                    + std::string("{{ x[0: fbegin] }}")
                                    + Format::url_encode(swagger::format({{ _name(param) }}))
                                    + std::string("{{ x[rbegin+1:] }}"));
                            {%- endfor %}
                        {%- else %}
                            sPath += "/{{ x }}";
                        {%- endif %}
                    {%- endif %}
                    {%- endfor %}

                    if (!sPath.empty())
                        sRequest.url += sPath;

                    {% if params | selectattr('in', 'equalto', 'query') | list | length > 0 %}
                        std::list<std::pair<std::string, std::string>> sParams;
                        {%- for param in params if param['in'] == 'query' %}
                            if (swagger::is_specified({{ _name(param) }}) )
                                sParams.push_back({"{{param.name}}", swagger::format({{ _name(param) }})});
                        {%- endfor %}
                        std::stringstream sStream;
                        Format::List(sStream, sParams, [](const auto x){
                            return x.first + '=' + Format::url_encode(x.second);
                        }, "&");
                        auto sQuery = sStream.str();
                        if (!sQuery.empty())
                            sRequest.url += '?' + sQuery;
                    {%endif %}

                    {%- for param in params if param['in'] == 'header' %}
                        if (swagger::is_specified({{ _name(param) }}) )
                            sRequest.headers[http::string_to_field("{{ param.name }}")] = Format::url_encode(swagger::format({{ _name(param) }}));
                    {%- endfor %}

                    {%- if binary > 0 %}
                        sRequest.headers[http::field::content_type] = "application/octet-stream";
                        sRequest.body = body;
                    {%- elif json > 0 %}
                        cbor::omemstream sOut;
                        cbor::write(sOut, body);
                        sRequest.headers[http::field::content_type] = "application/cbor";
                        sRequest.body = sOut.str();
                    {%- endif %}

                    return sRequest;
                }
            };

            {% call(name, k, response) _for_every_response(doc, path, method, name) %}
            struct {{ name }}_response_{{ k }}
                {%- if k | int >= 300 %} : public {{ _err_class(k) }}{%- endif %}
            {
                {%- set binary = response.get('content',{}).get('application/octet-stream',{}) | length %}
                {%- set json = response.get('content',{}).get('application/json',{}) | length %}
                {%- if binary > 0 %}
                    std::string body;
                {%- elif json > 0 %}
                    {%- set schema = response.get('content',{}).get('application/json').get('schema') %}
                    {{ complex_schema(schema) }}
                {%- endif %}

                {%- set headers = response.get('headers',{}) %}
                {%- for k,v in headers | dictsort %}
                    {{ complex_schema(v['schema'], _name(k), True) }}
                {%- endfor %}

                void __format(const asio_http::Request& aRequest, asio_http::Response& aResponse) {
                    {#  format response body #}
                    {%- if binary > 0 %}
                        aResponse.set(boost::beast::http::field::content_type, "application/octet-stream");
                        aResponse.body() = std::move(body);
                    {%- elif json > 0 %}
                        const auto sAccept = aRequest["Accept"];
                        const auto sContentType = aRequest["Content-Type"];
                        if (sAccept == "application/cbor" or (sAccept.empty() and sContentType == "application/cbor")) {
                            cbor::omemstream sOut;
                            cbor::write(sOut, body);
                            aResponse.set(boost::beast::http::field::content_type, "application/cbor");
                            aResponse.body() = std::move(sOut.str());
                        } else {
                            ::Json::Value sValue = Format::Json::to_value(body);
                            aResponse.set(boost::beast::http::field::content_type, "application/json");
                            aResponse.body() = Format::Json::to_string(sValue);
                        }
                    {%- endif %}

                    {#  push response headers #}
                    {%- for k,v in headers | dictsort %}
                        if ( swagger::is_specified({{ _name(k) }}) )
                            aResponse.set("{{ k }}", Format::url_encode(swagger::format({{ _name(k) }})));
                    {%- endfor -%}

                    aResponse.result({{ k }});
                }

                void __parse(asio_http::Response& aResponse)
                {
                    {%- if binary > 0 %}
                        body = aResponse.body();
                    {%- elif json > 0 %}
                        if (aResponse["Content-Type"] == "application/cbor") {
                            cbor::imemstream sIn(aResponse.body());
                            cbor::read(sIn, body);
                        } else {
                            const auto sJson = Parser::Json::parse(aResponse.body());
                            Parser::Json::from_value(sJson, body);
                        }
                    {%- endif %}

                    {%- for k,v in headers | dictsort %}
                        if (auto sValue = Parser::url_decode(aResponse["{{ k }}"].to_string()); !sValue.empty())
                            swagger::parse(sValue, {{ _name(k) }});
                    {%- endfor %}
                }

                {#  default c-tor for runtime-error #}
                {%- if k | int >= 300 %}
                    {{ name }}_response_{{ k }}() : {{ _err_class(k) }}("{{ response['description'] }}"){}
                {%- endif %}
            };
            {%- endcall %}
        {% endcall %}

        struct server
        {
        {% call(doc, path, method, name) _for_every_method(doc) %}
            using {{ name }}_parameters = {{ Aname }}::{{ name }}_parameters;
            {% call(name, k, response) _for_every_response(doc, path, method, name) %}
                using {{ name }}_response_{{ k }} = {{ Aname }}::{{ name }}_response_{{ k }};
            {% endcall %}
            void {{ name }}(asio_http::asio::io_service& aService, const asio_http::Request& aRequest, asio_http::Response& aResponse, asio_http::asio::yield_context yield)
            {
                namespace http = boost::beast::http;

                {{ name }}_parameters sParameters;

                try {
                    sParameters.__parse(aRequest);
                }
                catch (const std::exception& e) {
                    aResponse.result(http::status::bad_request);
                    aResponse.set("X-From-Swagger", "1");
                    aResponse.body() = e.what();
                    return;
                }

                try {
                    auto sResponse = {{ name }}_i(aService, sParameters, yield);
                    std::visit([&](auto&& arg) {
                        using T = std::decay_t<decltype(arg)>;
                        if constexpr (std::is_same_v<T, boost::beast::http::status>)
                        {
                            aResponse.result(arg);
                            aResponse.set("X-From-Swagger", "1");
                        } else {
                            arg.__format(aRequest, aResponse);
                        }
                    }, sResponse);
                } catch (const std::exception& e) {
                    aResponse.result(http::status::internal_server_error);
                    aResponse.set("X-From-Swagger", "1");
                    aResponse.body() = e.what();
                }
            }
        {% endcall %}

            void configure(asio_http::RouterPtr aRouter) {
                namespace http = boost::beast::http;
                {%- for path in doc['paths'] %}
                aRouter->insert("{{ (doc['servers'][0]['url'], path) | join('') | swagger_prefix }}",
                                [this](asio_http::asio::io_service& aService, const asio_http::Request& aRequest, asio_http::Response& aResponse, asio_http::asio::yield_context yield)
                                {
                                    switch (aRequest.method())
                                    {
                                    {%- for method in doc['paths'][path] if method in ["get", "put", "post", "head", "delete"] %}
                                        {%- set name = _name(doc['paths'][path][method]['operationId']) %}
                                        {%- if name == '' %}
                                            {%- set name = (doc['servers'][0]['url'], path) | join('') | swagger_prefix | replace('/','_') %}
                                        {% endif %}
                                        case http::verb::{{ method | swagger_method }}:
                                            {{ name }}(aService, aRequest, aResponse, yield);
                                            break;
                                    {%- endfor -%}
                                    default: aResponse.result(http::status::method_not_allowed);
                                    }
                                });
                {% endfor %}
            }

        {# server can respond with plain http status #}
        {% call(doc, path, method, name) _for_every_method(doc) %}
            using {{ name }}_response_v = std::variant<
                boost::beast::http::status
                {%- call(name, k, response) _for_every_response(doc, path, method, name) -%}
                    , {{ Aname }}::{{ name }}_response_{{ k }}
                {%- endcall %}
            >;
            virtual {{ name }}_response_v
                {{ name }}_i(asio_http::asio::io_service& aService,
                             const {{ name }}_parameters& aRequest,
                             asio_http::asio::yield_context yield)
            {
                return {boost::beast::http::status::not_implemented};
            }
        {% endcall %}
            virtual ~server() {}
        };

        class client
        {
            Threads::Asio& m_Asio;
            const std::string m_Base;

        public:
            client(Threads::Asio& aAsio, const std::string& aBase)
            : m_Asio(aAsio)
            , m_Base(aBase)
            {}

            {% call(doc, path, method, name) _for_every_method(doc) %}
                using {{ name }}_parameters = {{ Aname }}::{{ name }}_parameters;

                {# detect if we have only one successul response kind #}
                {%- set variant_list = [] %}
                {%- call(name, k, response) _for_every_response(doc, path, method, name) -%}
                    {%- if k | int < 300 %}
                        {% do variant_list.append( Aname + "::" + name + "_response_" + k ) %}
                    {%- endif %}
                {%- endcall %}
                {%- if variant_list | length == 1 %}
                    {%- set returnType = variant_list | first %}
                {%- else %}
                    using {{ name }}_response_v = std::variant<
                        {{ variant_list | join(',') }}
                    >;
                    {%- set returnType = name + "_response_v" %}
                {%- endif %}

                {# client response with successful struct, or throw #}
                {{ returnType }} {{ name }}(const {{ name }}_parameters& aRequest)
                {
                    namespace http = boost::beast::http;
                    asio_http::ClientRequest sRequest = aRequest.__format();
                    sRequest.url = m_Base + sRequest.url;
                    auto sResponse = asio_http::async(m_Asio, std::move(sRequest)).get();
                    const auto sFromSwagger = !sResponse["X-From-Swagger"].empty();

                    {# default error codes (w/o without content-type) #}
                    if (sFromSwagger)
                    {
                        if (sResponse.result() == asio_http::http::status::bad_request)
                            throw std::invalid_argument(sResponse.body());
                        throw Exception::HttpError(
                            sResponse.body(),
                            static_cast<unsigned>(sResponse.result()));
                    }

                    {# normal user responses #}
                    {% call(name, k, response) _for_every_response(doc, path, method, name) %}
                        if (sResponse.result() == asio_http::http::int_to_status({{ k }}))
                        {
                            {{ name }}_response_{{ k }} sResponseBody;
                            sResponseBody.__parse(sResponse);
                            {%- if k | int < 300 %}
                                return sResponseBody;
                            {%- else %}
                                throw sResponseBody;
                            {%- endif %}
                        }
                    {% endcall %}

                    {# no match - throw #}
                    throw Exception::HttpError(
                        "unexpected http response: " + sResponse.body(),
                        static_cast<unsigned>(sResponse.result()));
                }
            {% endcall %}
        };
    }
} // namespace api
