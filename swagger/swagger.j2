#include <set>
#include <string>
#include <vector>

#include <asio_http/Router.hpp>
#include <cbor/cbor.hpp>
#include <format/Json.hpp>
#include <parser/Atoi.hpp>
#include <parser/Json.hpp>
#include <parser/Url.hpp>

{% macro complex_schema(schema, mode) -%}
    {%- for s in schema | swagger_decode() %}
        {%- if 'fields' in s %}
            struct {{ s.type }} {
                {%- for t in s.fields | sort(attribute='name') %}
                    {{ t.type | swagger_type }} {{ t.name }} = {};
                {%- endfor %}
                {%- if mode %}
                    ::Json::Value to_json() const {
                        ::Json::Value sValue(::Json::objectValue);
                        {%- for t in s.fields | sort(attribute='name') %}
                            sValue["{{ t.name }}"] = Format::Json::to_value({{ t.name }});
                        {%- endfor %}
                        return sValue;
                    }
                    void cbor_write(cbor::ostream& out) const {
                        {%- for t in s.fields | sort(attribute='name') %}
                            cbor::write(out, {{ t.name }});
                        {%- endfor %}
                    }
                {%- else %}
                    void from_json(const ::Json::Value& aJson) {
                    {%- for t in s.fields | sort(attribute='name') %}
                        Parser::Json::from_value(aJson, "{{ t.name }}", {{ t.name }});
                    {%- endfor %}
                    }
                    void cbor_read(cbor::istream& in) {
                    {%- for t in s.fields | sort(attribute='name') %}
                        cbor::read(in, {{ t.name }});
                    {%- endfor %}
                    }
                {%- endif %}
            };
            {%- if loop.last %}
                {{ s.type | swagger_type }} {{ s.name }};
            {%- endif %}
        {%- else %}
            {{ s.type | swagger_type }} {{ s.name }};
        {%- endif %}
    {%- endfor %}
{%- endmacro %}


namespace api {
    {% set name = (doc['info']['title'], doc['info']['version']) | join('_') | replace('.', '_') %}
    struct {{ name }}
    {
        {% for path in doc['paths'] %}
        {%- for method in doc['paths'][path]: %}
        {%- if method in ["get", "put", "post", "head", "delete"] %}
            {%- set name = doc['paths'][path][method]['operationId'] | lower | replace('-', '_') %}

        struct {{ name }}_parameters {
            {# parameters #}
            {%- set p1 = doc['paths'][path].get('parameters', []) | swagger_expand_refs %}
            {%- set p2 = doc['paths'][path][method].get('parameters', []) | swagger_expand_refs %}
            {%- set params = p1 + p2 | sort(attribute='name') %}

            {%- for param in params %}
                {%- if param['schema']['type'] == 'array' %}
                    {%- if param.get('style', 'form') != 'form' or param.get('explode', True) != False %}
                    {{ swagger_raise('[style: form, explode: False] arrays only supported') }}
                    {%- endif %}
                    std::vector<{{ param['schema']['items']['type'] | swagger_type }}> {{ param | swagger_name }};
                {%- else %}
                    std::optional<{{ param['schema']['type'] | swagger_type }}> {{ param | swagger_name }};
                {%- endif %}
            {%- endfor %}

            {# body #}
            {%- set body = doc['paths'][path][method].get('requestBody',{}).get('content',{}) %}
            {%- set binary = body.get('application/octet-stream',{}) | length %}
            {%- set json = body.get('application/json',{}) | length %}
            {%- if binary > 0 %}
                std::string body;
            {%- elif json > 0 %}
                {%- set schema = body.get('application/json').get('schema') %}
                {{ complex_schema(schema, false) }}
            {% endif %}

            void __parse(const asio_http::Request& aRequest) {
                auto sQuery = aRequest.target();
                std::string_view sQueryView(sQuery.data(), sQuery.size());

                {% if params | selectattr('in', 'equalto', 'path') | list | length > 0 %}
                Parser::http_path_params(sQueryView, "{{ (doc['servers'][0]['url'], path) | join('') | swagger_path }}", [this](auto aName, auto aValue) {
                    {%- for param in params if param['in'] == 'path' %}
                        if (aName == "{{ param['name'] }}") { this->{{ param | swagger_name }} = {{ param | swagger_assign('aValue') }}; return; }
                    {%- endfor %}
                    throw std::invalid_argument("unexpected param `" + std::string(aName) + '`');
                });
                {%- endif %}

                Parser::http_query(sQueryView, [this](auto aName, auto aValue) {
                    {%- for param in params if param['in'] == 'query' %}
                        if (aName == "{{ param['name'] }}") {
                            {%- if param['schema']['type'] == 'array' %}
                                Parser::simple(aValue, [this](auto x) mutable {
                                    this->{{ param | swagger_name }}.push_back({{ param | swagger_assign('std::string(x)') }});
                                }, ',');
                            {%- else %}
                                this->{{ param | swagger_name }} = {{ param | swagger_assign('aValue') }};
                            {%- endif %}
                            return;
                        }
                    {%- endfor %}
                    throw std::invalid_argument("unexpected param `" + std::string(aName) + '`');
                });

                {%- for param in params if param['in'] == 'header' %}
                    {
                        const auto sValue = aRequest["{{ param['name'] }}"].to_string();
                        if (!sValue.empty()) this->{{ param | swagger_name }} = {{ param | swagger_assign('sValue') }};
                    }
                {%- endfor %}

                {%- for param in params if param['schema'].get('enum', none) is not none %}
                    if (this->{{ param | swagger_name }}.has_value()) {
                        static const std::set<{{ param['schema']['type'] | swagger_type }}> sAllowed ={ {{ param | swagger_enum }} };
                        if (sAllowed.find(this->{{ param | swagger_name }}.value()) == sAllowed.end())
                            throw std::invalid_argument("param `{{ param['name'] }}` has not allowed value");
                    }
                {%- endfor %}

                {%- for param in params if param['schema'].get('default', none) is not none %}
                    {%- set d = param['schema']['default'] %}
                    if (!this->{{ param | swagger_name }}.has_value())
                        this->{{ param | swagger_name }} =
                        {%- if d is string -%}
                            "{{ d }}"
                        {%- elif d is boolean -%}
                            {%- if d -%} true {%- else -%} false {%- endif -%}
                        {%- else -%}
                            {{ d }}
                        {%- endif -%};
                {%- endfor %}

                {%- for param in params if param['required'] and param['schema'].get('default', none) is none %}
                    {%- if param['schema']['type'] == 'array' %}
                        if (this->{{ param | swagger_name }}.empty())
                    {%- else %}
                        if (!this->{{ param | swagger_name }}.has_value())
                    {%- endif %}
                        throw std::invalid_argument("required param `{{ param['name'] }}` not specified");
                {%- endfor %}

                {# parse body #}
                {%- if binary > 0 %}
                    body = aRequest.body();
                {%- elif json > 0 %}
                    if (aRequest["Content-Type"] == "application/cbor") {
                        auto sIn = cbor::imemstream(aRequest.body());
                        cbor::read(sIn, body);
                    } else {
                        const auto sJson = Parser::Json::parse(aRequest.body());
                        Parser::Json::from_value(sJson, body);
                    }
                {%- endif %}
            }
        };

        struct {{ name }}_response {
            {%- set r200 = doc['paths'][path][method].get('responses',{}).get('200',{}) | swagger_expand_ref %}
            {%- set binary = r200.get('content',{}).get('application/octet-stream',{}) | length %}
            {%- set json = r200.get('content',{}).get('application/json',{}) | length %}
            {%- if binary > 0 %}
                std::string body;
            {% elif json > 0 %}
                {%- set schema = r200.get('content',{}).get('application/json').get('schema') %}
                {{ complex_schema(schema, true) }}
            {%- endif %}

            {%- set headers = r200.get('headers',{}) %}
            {%- for k,v in headers | dictsort %}
                std::optional<{{ v.schema.type | swagger_type }}> {{ k | lower | replace('-','_') }};
            {%- endfor %}

            void __format(const asio_http::Request& aRequest, asio_http::Response& aResponse) {
                {#  format response body #}
                {%- if binary > 0 %}
                    aResponse.set(boost::beast::http::field::content_type, "application/octet-stream");
                    aResponse.body().append(body);
                {%- elif json > 0 %}
                    const auto sAccept = aRequest["Accept"];
                    const auto sContentType = aRequest["Content-Type"];
                    if (sAccept == "application/cbor" or (sAccept.empty() and sContentType == "application/cbor")) {
                        cbor::omemstream sOut;
                        cbor::write(sOut, body);
                        aResponse.set(boost::beast::http::field::content_type, "application/cbor");
                        aResponse.body().append(sOut.str());
                    } else {
                        ::Json::Value sValue = Format::Json::to_value(body);
                        aResponse.set(boost::beast::http::field::content_type, "application/json");
                        aResponse.body().append(Format::Json::to_string(sValue));
                    }
                {%- endif %}

                {#  push response headers #}
                {%- set headers = r200.get('headers',{}) %}
                {%- for k,v in headers | dictsort %}
                    if ({{ k | replace('-','_') }}.has_value())
                        aResponse.set("{{ k }}", {{ k | lower | replace('-','_') }}.value());
                {%- endfor %}
            }
        };

        void {{name}}(asio_http::asio::io_service& aService, const asio_http::Request& aRequest, asio_http::Response& aResponse, asio_http::asio::yield_context yield)
        {
            namespace http = boost::beast::http;

            {{name}}_parameters sParameters;

            try {
                sParameters.__parse(aRequest);
            }
            catch (const std::invalid_argument& e) {
                aResponse.result(http::status::bad_request);
                aResponse.body().append(e.what());
                return;
            }
            catch (const std::exception& e) {
                aResponse.result(http::status::bad_request);
                return;
            }

            try {
                auto [sStatus, sResponse] = {{name}}_i(aService, sParameters, yield);
                aResponse.result(sStatus);
                sResponse.__format(aRequest, aResponse);
            } catch (const std::exception& e) {
                aResponse.result(http::status::internal_server_error);
                return;
            }
        }
            {%- endif %}
        {%- endfor %}
        {%- endfor %}

        void configure(asio_http::RouterPtr aRouter) {
            namespace http = boost::beast::http;
            {% for path in doc['paths'] %}
            aRouter->insert("{{ (doc['servers'][0]['url'], path) | join('') | swagger_prefix }}",
                            [this](asio_http::asio::io_service& aService, const asio_http::Request& aRequest, asio_http::Response& aResponse, asio_http::asio::yield_context yield)
                            {
                                switch (aRequest.method())
                                {
                                {%- for method in doc['paths'][path]: %}
                                {%- if method in ["get", "put", "post", "head", "delete"] %}
                                {%- set name = doc['paths'][path][method]['operationId'] | lower | replace('-', '_') %}
                                case http::verb::{{ method | swagger_method }}:
                                    {{ name }}(aService, aRequest, aResponse, yield);
                                    break;
                                {%- endif %}
                                {%- endfor -%}
                                default: aResponse.result(http::status::method_not_allowed);
                                }
                            });
            {% endfor %}
        }

        {% for path in doc['paths'] %}
        {%- for method in doc['paths'][path] if method in ["get", "put", "post", "head", "delete"] %}
            {%- set name = doc['paths'][path][method]['operationId'] | lower | replace('-', '_') %}
            virtual std::pair<boost::beast::http::status, {{name}}_response> {{ name }}_i
            (asio_http::asio::io_service& aService, const {{name}}_parameters& aRequest, asio_http::asio::yield_context yield) = 0;
        {%- endfor %}
        {%- endfor %}

        virtual ~{{ name }}() {}
    };
} // namespace api
