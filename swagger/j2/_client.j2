{% if not x_hpp_name %}
class client
{
    asio_http::ClientPtr m_HttpClient;
{%- if x_discovery %}
    const std::string m_Service;
    std::shared_ptr<SD::Balancer> m_Balancer;
    std::shared_ptr<SD::Breaker> m_Breaker;
{%- else %}
    const std::string m_Base;
{%- endif %}
    log4cxx::LoggerPtr sLogger = Logger::Get("http");
    {% if x_bearer %}
    std::string m_Token;
    {% endif %}

    using Lock = std::unique_lock<std::mutex>;
    std::mutex m_Mutex;
    {%- call(doc, path, method, name) _for_every_method(doc) %}
        {%- if x_discovery %}
            std::map<std::string, std::string> m_{{ name }}_redirect = {};
        {%- else -%}
            std::string m_{{ name }}_redirect = {};
        {%- endif %}
    {%- endcall %}

public:
    {% if x_discovery %}
        client(asio_http::ClientPtr aHttpClient, boost::asio::io_service& aAsio, const std::string& aService, const std::string& aLocation = {});
        void with_breaker();
    {% else %}
        client(asio_http::ClientPtr aHttpClient, const std::string& aBase);
    {% endif %}
    {% if x_bearer %}
        void __with_token(const std::string& aToken);
    {% endif %}

    {% call(doc, path, method, name) _for_every_method(doc) %}
        // {{ name }}
        using {{ name }}_parameters = {{ Aname }}::{{ name }}_parameters;
        {%- set variant_list = [] -%}
        {%- call(name, k, response) _for_every_response(doc, path, method, name) %}
            {%- if k | int < 400 %}
                {%- do variant_list.append( Aname + "::" + name + "_response_" + k ) %}
            {%- endif %}
        {%- endcall %}
        {%- if variant_list | length == 1 %}
            {%- set returnType = variant_list | first %}
        {%- else -%}
            using {{ name }}_response_v = std::variant<
                {{ variant_list | join(',') }}
            >;
            {%- set returnType = name + "_response_v" %}
        {%- endif %}
        using {{ name }}_response = {{ returnType }};
        {{ name }}_response {{ name }}(const {{ name }}_parameters& aRequest {% if x_jaeger %}, Jaeger::Span* aTraceParent = nullptr{% endif %});

    {% endcall %}
};

{% else %} {# CPP #}

    {% if x_discovery %}
        client::client(asio_http::ClientPtr aHttpClient, boost::asio::io_service& aAsio, const std::string& aService, const std::string& aLocation)
        : m_HttpClient(aHttpClient)
        , m_Service(aService)
        {
            SD::Balancer::Params sParams;
            sParams.prefix = "discovery/swagger/" + aService + "/{{ doc['info']['title'] }}/{{ doc['info']['version'] }}/";
            sParams.location = aLocation;
            m_Balancer = std::make_shared<SD::Balancer>(aAsio, sParams);
            m_Balancer->start();
        }
        void client::with_breaker()
        {
            m_Breaker = SD::getBreaker(m_Service + "/{{ doc['info']['title'] }}/{{ doc['info']['version'] }}");
        }
    {% else %}
        client::client(asio_http::ClientPtr aHttpClient, const std::string& aBase)
        : m_HttpClient(aHttpClient)
        , m_Base(aBase)
        {}
    {% endif %}

    {% if x_bearer %}
    void client::__with_token(const std::string& aToken)
    {
        m_Token = aToken;
    }
    {% endif %}

    {% call(doc, path, method, name) _for_every_method(doc) %}
        {# client response with successful struct, or throw #}
        client::{{ name }}_response client::{{ name }}(const {{ name }}_parameters& aRequest {% if x_jaeger %}, Jaeger::Span* aTraceParent{% endif %})
        {
            namespace http = boost::beast::http;
            asio_http::ClientRequest sRequest = aRequest.__format();
            auto sPick = [this]()
            {
                Lock sLock(m_Mutex);
                {%- if x_discovery %}
                    std::string sPeer = m_Balancer->random().key;
                    auto sIt = m_{{ name }}_redirect.find(sPeer);
                    if (sIt == m_{{ name }}_redirect.end())
                    {
                        return sPeer;
                    }
                    else
                    {
                        DEBUG("permanent redirected to " << sIt->second);
                        return sIt->second;
                    }
                {%- else %}
                    if (m_{{ name }}_redirect.empty())
                    {
                        return m_Base;
                    }
                    else
                    {
                        DEBUG("permanent redirected to " << m_{{ name }}_redirect);
                        return m_{{ name }}_redirect;
                    }
                {%- endif %}
            };
            std::string sPeer = sPick();
            sRequest.url = "http://" + sPeer + sRequest.url;

            {% if x_jaeger %}
            std::unique_ptr<Jaeger::Span> sTraceCall;
            if (aTraceParent)
            {
                sTraceCall = std::make_unique<Jaeger::Span>(aTraceParent->child("call {{ Aname }}/{{ name }}"));
                sRequest.headers["traceparent"] = sTraceCall->extract().traceparent();
            }
            {% endif %}
            {% if x_bearer %}
            if (!m_Token.empty())
                sRequest.headers["Authorization"] = "Bearer " + m_Token;
            {% endif %}

            asio_http::Response sResponse;
            int64_t sRedirectCount = 0;
            while (sRedirectCount < 5) {# up to 5 redirects #}
            {
                INFO("{{ method }} " << sRequest.url {% if x_jaeger %} << ( sTraceCall ? " [J:" + sTraceCall->trace_id() + "]" : "") {% endif %});
                {# copy request to make a call, since we need one if redirect #}
                {%- if x_discovery %}
                if (m_Breaker)
                    sResponse = m_Breaker->wrap(sPeer, [&, this]() {
                        try {
                            return m_HttpClient->async(asio_http::ClientRequest(sRequest)).get();
                        } catch (const SD::Breaker::Error& e) {
                            {% if x_jaeger %}
                            if (sTraceCall)
                                sTraceCall->set_tag(Jaeger::Tag{"circuit_breaker", 1});
                            {% endif %}
                            throw;
                        }
                    });
                else
                {%- endif %}
                    sResponse = m_HttpClient->async(asio_http::ClientRequest(sRequest)).get();

                if (sResponse.result() == asio_http::http::status::temporary_redirect or
                    sResponse.result() == asio_http::http::status::found)
                {
                    DEBUG("temporary redirect");
                    const auto sLocation = sResponse[asio_http::http::field::location];
                    if (sLocation.empty())
                        throw Exception::HttpError(
                            "redirect without location",
                            static_cast<unsigned>(sResponse.result())
                        );
                    sRequest.url = sLocation.to_string();
                    const auto sParsed = Parser::url(sLocation.to_string());
                    sPeer = sParsed.host + ":" + sParsed.port;
                }
                else if (sResponse.result() == asio_http::http::status::permanent_redirect or
                         sResponse.result() == asio_http::http::status::moved_permanently)
                {
                    DEBUG("permanent redirect");
                    const auto sLocation = sResponse[asio_http::http::field::location];
                    if (sLocation.empty())
                        throw Exception::HttpError(
                            "redirect without location",
                            static_cast<unsigned>(sResponse.result())
                        );
                    sRequest.url = sLocation.to_string();
                    const auto sParsed = Parser::url(sLocation.to_string());
                    sPeer = sParsed.host + ":" + sParsed.port;
                    Lock sLock(m_Mutex);
                    {%- if x_discovery %}
                        m_{{ name }}_redirect[sPeer] = sPeer;
                    {%- else %}
                        m_{{ name }}_redirect = sPeer;
                    {%- endif %}
                }
                else
                {
                    break;
                }
                sRedirectCount++;
            }
            {% if x_jaeger %}
            if (sRedirectCount > 0 and sTraceCall)
                sTraceCall->set_tag(Jaeger::Tag{"redirect_count", sRedirectCount});
            {% endif %}

            {# error codes from swagger #}
            const auto sFromSwagger = !sResponse["X-From-Swagger"].empty();
            if (sFromSwagger)
            {
                if (sResponse.result() == asio_http::http::status::bad_request)
                    throw std::invalid_argument(sResponse.body());
                throw Exception::HttpError(
                    sResponse.body(),
                    static_cast<unsigned>(sResponse.result()));
            }

            {# normal user responses #}
            {% call(name, k, response) _for_every_response(doc, path, method, name) %}
                if (sResponse.result() == asio_http::http::int_to_status({{ k }}))
                {
                    {{ name }}_response_{{ k }} sResponseBody;
                    sResponseBody.__parse(sResponse);
                    {%- if k | int < 400 %}
                        return sResponseBody;
                    {%- else %}
                        throw sResponseBody;
                    {%- endif %}
                }
            {% endcall %}

            {# no match - throw #}
            throw Exception::HttpError(
                "unexpected http response: " + sResponse.body(),
                static_cast<unsigned>(sResponse.result()));
        }
    {% endcall %}
{% endif %}